<!DOCTYPE html>
<html>
  <head>
  <title>PCL库学习笔记 – zxl19 – 一个工程师的存档点</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="我的点云库（Point Cloud Library，PCL）学习笔记。

" />
    <meta property="og:description" content="我的点云库（Point Cloud Library，PCL）学习笔记。

" />
    
    <meta name="author" content="zxl19" />

    
    <meta property="og:title" content="PCL库学习笔记" />
    <meta property="twitter:title" content="PCL库学习笔记" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

<!--adobe fonts-->
<script>
    (function(d) {
      var config = {
        kitId: 'vbt3gjx',
        scriptTimeout: 3000,
        async: true
      },
      h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
    })(document);
</script> 

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="zxl19 - 一个工程师的存档点" href="/feed.xml" />
  <link rel="shortcut icon" href="https://raw.githubusercontent.com/zxl19/zxl19.github.io/master/images/icon.png">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script src="https://unpkg.com/feather-icons"></script>
  <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->

</head>

  <body>
    <div class="wrapper-sidebar">
  <header class="sidebar clearfix">
    <div class="site-info">
      
        <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/zxl19/zxl19.github.io/master/images/avatar.jpg" /></a>
       
      <h1 class="site-name"><a href="/">zxl19</a></h1>
      <p class="site-description">一个工程师的存档点</p>
    </div>
  </header>

  <div class="navlist">
    <nav>
      
      
      <a href="/">首页</a>
      
      
      
      <a href="/about">关于</a>
      
      
      
      <a href="/archive">归档</a>
      
      
      
      <a href="/tags">标签</a>
      
      
    </nav>
  </div>

  <div class="wrapper-footer-desktop">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  

  

  

  
  <li><a href="https://github.com/zxl19" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright © 2020-2025 zxl19. All Rights Reserved.</p>

    </footer>
  </div>
</div>

    
      <aside class="toc">
        <ul>
  <li><a href="#">PCL库学习笔记</a>
    <ul>
      <li><a href="#pcl-hello-world">PCL Hello World</a>
        <ul>
          <li><a href="#模块">模块</a></li>
          <li><a href="#安装">安装</a></li>
          <li><a href="#cmakelists">CMakeLists</a></li>
        </ul>
      </li>
      <li><a href="#基础数据结构">基础数据结构</a>
        <ul>
          <li><a href="#点">点</a></li>
          <li><a href="#点云">点云</a></li>
        </ul>
      </li>
      <li><a href="#滤波">滤波</a>
        <ul>
          <li><a href="#passthrough">PassThrough</a></li>
          <li><a href="#voxelgrid">VoxelGrid</a></li>
          <li><a href="#approximatevoxelgrid">ApproximateVoxelGrid</a></li>
          <li><a href="#statisticaloutlierremoval">StatisticalOutlierRemoval</a></li>
          <li><a href="#radiusoutlierremoval">RadiusOutlierRemoval</a></li>
          <li><a href="#conditionalremoval">ConditionalRemoval</a></li>
        </ul>
      </li>
      <li><a href="#配准">配准</a>
        <ul>
          <li><a href="#icp">ICP</a></li>
          <li><a href="#ndt">NDT</a></li>
        </ul>
      </li>
      <li><a href="#kdtree">KdTree</a></li>
      <li><a href="#输入输出">输入输出</a>
        <ul>
          <li><a href="#pcd文件格式">PCD文件格式</a></li>
          <li><a href="#输入">输入</a></li>
          <li><a href="#输出">输出</a></li>
        </ul>
      </li>
      <li><a href="#可视化">可视化</a></li>
      <li><a href="#资料">资料</a>
        <ul>
          <li><a href="#网站">网站</a></li>
          <li><a href="#github">GitHub</a></li>
        </ul>
      </li>
      <li><a href="#参考">参考</a></li>
    </ul>
  </li>
</ul>
      </aside>
    

    <div id="main" role="main" class="wrapper-content">
      <div class="container">
        <article class="posts">
  <h1>PCL库学习笔记</h1>

  <div clsss="meta">
    <span class="author">
      zxl19
    </span>

    <span class="date">
      2021-11-28
    </span>

    <ul class="tag">
      
      <li>
        <a href="http://localhost:4000/tags#C++">
          C++
        </a>
      </li>
      
      <li>
        <a href="http://localhost:4000/tags#PCL">
          PCL
        </a>
      </li>
      
      <li>
        <a href="http://localhost:4000/tags#Note">
          Note
        </a>
      </li>
      
    </ul>
  </div>

  <div class="entry">
    <p>我的点云库（Point Cloud Library，PCL）学习笔记。</p>

<!-- more -->

<h2 id="pcl-hello-world">PCL Hello World</h2>

<h3 id="模块">模块</h3>

<p>按照功能，PCL包含以下几个模块：</p>

<ol>
  <li>滤波（Filters）；</li>
  <li>特征（Features）；</li>
  <li>关键点（Keypoints）；</li>
  <li>配准（Registration）；</li>
  <li>K-D树（KdTree）；</li>
  <li>八叉树（Octree）；</li>
  <li>分割（Segmentation）；</li>
  <li>采样一致（Sample Consensus）；</li>
  <li>表面（Surface）；</li>
  <li>深度图（Range Image）；</li>
  <li>输入输出（I/O）；</li>
  <li>可视化（Visualization）；</li>
  <li>公共（Common）；</li>
  <li>搜索（Search）；</li>
</ol>

<h3 id="安装">安装</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>libpcl-dev
</code></pre></div></div>

<h3 id="cmakelists">CMakeLists</h3>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.6 FATAL_ERROR<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>MY_GRAND_PROJECT<span class="p">)</span>
<span class="nb">find_package</span><span class="p">(</span>PCL 1.3 REQUIRED COMPONENTS common io<span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PCL_INCLUDE_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">link_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PCL_LIBRARY_DIRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_definitions</span><span class="p">(</span><span class="si">${</span><span class="nv">PCL_DEFINITIONS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span>pcd_write_test pcd_write.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>pcd_write_test <span class="si">${</span><span class="nv">PCL_LIBRARIES</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="基础数据结构">基础数据结构</h2>

<h3 id="点">点</h3>

<ol>
  <li>
    <p>PCL在<code class="language-plaintext highlighter-rouge">point_types.hpp</code>中定义了支持的点的类型，以下为包含XYZ坐标的点的类型：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// Define all point types that include XYZ data</span>
 <span class="cp">#define PCL_XYZ_POINT_TYPES   \
   (pcl::PointXYZ)             \
   (pcl::PointXYZI)            \
   (pcl::PointXYZL)            \
   (pcl::PointXYZRGBA)         \
   (pcl::PointXYZRGB)          \
   (pcl::PointXYZRGBL)         \
   (pcl::PointXYZLAB)          \
   (pcl::PointXYZHSV)          \
   (pcl::InterestPoint)        \
   (pcl::PointNormal)          \
   (pcl::PointXYZRGBNormal)    \
   (pcl::PointXYZINormal)      \
   (pcl::PointXYZLNormal)      \
   (pcl::PointWithRange)       \
   (pcl::PointWithViewpoint)   \
   (pcl::PointWithScale)       \
   (pcl::PointSurfel)          \
   (pcl::PointDEM)
</span></code></pre></div>    </div>
  </li>
  <li>
    <p>PCL对于点的类型进行了内存对齐，使用SSE（Streaming SIMD Extensions）指令集进行向量化运算加速，以<code class="language-plaintext highlighter-rouge">pcl::PointXYZ</code>、<code class="language-plaintext highlighter-rouge">pcl::PointXYZI</code>、<code class="language-plaintext highlighter-rouge">pcl::PointRGBA</code>为例：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1">// PointXYZ</span>
 <span class="k">union</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
   <span class="p">};</span>
 <span class="p">};</span>
 <span class="c1">// PointXYZI</span>
 <span class="k">union</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
   <span class="p">};</span>
 <span class="p">};</span>
 <span class="k">union</span> <span class="p">{</span>
   <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">float</span> <span class="n">intensity</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="kt">float</span> <span class="n">data_c</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
 <span class="p">};</span>
 <span class="c1">// PointXYZRGBA</span>
 <span class="k">union</span> <span class="p">{</span>
   <span class="kt">float</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
   <span class="k">struct</span> <span class="p">{</span>
     <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
     <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
   <span class="p">};</span>
 <span class="p">};</span>
 <span class="k">union</span> <span class="p">{</span>
   <span class="k">union</span> <span class="p">{</span>
     <span class="k">struct</span> <span class="p">{</span>
       <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b</span><span class="p">;</span>
       <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">g</span><span class="p">;</span>
       <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">r</span><span class="p">;</span>
       <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">a</span><span class="p">;</span>
     <span class="p">};</span>
     <span class="kt">float</span> <span class="n">rgb</span><span class="p">;</span>
   <span class="p">};</span>
   <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">rgba</span><span class="p">;</span>
 <span class="p">};</span>
</code></pre></div>    </div>

    <ul>
      <li>点的坐标为float类型；</li>
      <li>可以通过结构体的数据成员直接读写对应的属性值；</li>
      <li>可以利用由于内存对齐多出来的<code class="language-plaintext highlighter-rouge">data[3]</code>保存信息，但是需要注意是float类型，防止截断；</li>
    </ul>
  </li>
  <li>
    <p>点的定义和初始化：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span> <span class="n">pt1</span><span class="p">;</span>
 <span class="c1">// 生成随机点</span>
 <span class="n">pt1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">pt1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">pt1</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGBA</span> <span class="n">pt2</span><span class="p">;</span>
 <span class="c1">// 生成随机点</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">z</span> <span class="o">=</span> <span class="mf">1024.0</span><span class="n">f</span> <span class="o">*</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">RAND_MAX</span> <span class="o">+</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
 <span class="c1">// 设置颜色</span>
 <span class="c1">// 方法一：分别对于每个通道赋值，推荐使用</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>    <span class="c1">// red: 0-255</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// green: 0-255</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="c1">// blue: 0-255</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>    <span class="c1">// transparency: 0-255</span>
 <span class="c1">// 方法二：通过位运算转换为单精度浮点数，由于历史原因存在，不推荐使用</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint8_t</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">rgb</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">b</span><span class="p">;</span>
 <span class="n">pt2</span><span class="p">.</span><span class="n">rgba</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">float</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">rgb</span><span class="p">);</span>  <span class="c1">// makes the point red</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>PCL中的点的类型可以与Eigen中的数据类型相互转换：</p>

    <ul>
      <li>
        <p>PCL使用<code class="language-plaintext highlighter-rouge">typedef</code>关键字重命名了<code class="language-plaintext highlighter-rouge">Eigen::Map</code>，通过内存映射进行相互转换：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Array3f</span><span class="o">&gt;</span> <span class="n">Array3fMap</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Array3f</span><span class="o">&gt;</span> <span class="n">Array3fMapConst</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Array4f</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Aligned</span><span class="o">&gt;</span> <span class="n">Array4fMap</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Array4f</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Aligned</span><span class="o">&gt;</span> <span class="n">Array4fMapConst</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span> <span class="n">Vector3fMap</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">&gt;</span> <span class="n">Vector3fMapConst</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Aligned</span><span class="o">&gt;</span> <span class="n">Vector4fMap</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Aligned</span><span class="o">&gt;</span> <span class="n">Vector4fMapConst</span><span class="p">;</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>PCL定义了返回引用和返回常引用两个版本的函数成员：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#define PCL_ADD_EIGEN_MAPS_POINT4D                                                              \
    inline pcl::Vector3fMap getVector3fMap() { return (pcl::Vector3fMap(data)); }                 \
    inline pcl::Vector3fMapConst getVector3fMap() const { return (pcl::Vector3fMapConst(data)); } \
    inline pcl::Vector4fMap getVector4fMap() { return (pcl::Vector4fMap(data)); }                 \
    inline pcl::Vector4fMapConst getVector4fMap() const { return (pcl::Vector4fMapConst(data)); } \
    inline pcl::Array3fMap getArray3fMap() { return (pcl::Array3fMap(data)); }                    \
    inline pcl::Array3fMapConst getArray3fMap() const { return (pcl::Array3fMapConst(data)); }    \
    inline pcl::Array4fMap getArray4fMap() { return (pcl::Array4fMap(data)); }                    \
    inline pcl::Array4fMapConst getArray4fMap() const { return (pcl::Array4fMapConst(data)); }
</span></code></pre></div>        </div>
      </li>
      <li>
        <p>在调用时可以作为等号左值和等号右值使用：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span> <span class="n">pt</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">pt</span><span class="p">.</span><span class="n">getVector3fMap</span><span class="p">()</span> <span class="o">=</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span> <span class="o">=</span> <span class="n">pt</span><span class="p">.</span><span class="n">getVector3fMap</span><span class="p">();</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>PCL支持自定义点的类型：</p>

    <ul>
      <li>
        <p>定义结构体，包括点的坐标和其他属性信息，注意需要声明内存对齐：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">struct</span> <span class="nc">EIGEN_ALIGN16</span> <span class="n">PointXYZIT</span> <span class="p">{</span>   <span class="c1">// enforce SSE padding for correct memory alignment</span>
    <span class="n">PCL_ADD_POINT4D</span>                   <span class="c1">// preferred way of adding a XYZ+padding</span>
    <span class="kt">uint8_t</span> <span class="n">intensity</span><span class="p">;</span>                <span class="c1">// 反射强度</span>
    <span class="kt">float</span> <span class="n">angle</span><span class="p">;</span>                      <span class="c1">// 线束俯仰角</span>
    <span class="kt">uint8_t</span> <span class="n">ring</span><span class="p">;</span>                     <span class="c1">// 线束编号</span>
    <span class="kt">double</span> <span class="n">timestamp</span><span class="p">;</span>                 <span class="c1">// 时间戳</span>
    <span class="n">EIGEN_MAKE_ALIGNED_OPERATOR_NEW</span>   <span class="c1">// make sure our new allocators are aligned</span>
  <span class="p">};</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>使用<code class="language-plaintext highlighter-rouge">POINT_CLOUD_REGISTER_POINT_STRUCT</code>宏将自定义结构体注册到PCL命名空间中，可以直接使用自定义的点构建点云，注意必须在全局命名空间中注册：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// clang-format off</span>
  <span class="n">POINT_CLOUD_REGISTER_POINT_STRUCT</span><span class="p">(</span><span class="n">PointXYZIT</span><span class="p">,</span>
                                    <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">float</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">uint8_t</span><span class="p">,</span> <span class="n">ring</span><span class="p">,</span> <span class="n">ring</span><span class="p">)</span>
                                    <span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">))</span>
  <span class="c1">// clang-format on</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h3 id="点云">点云</h3>

<ol>
  <li>PCL在<code class="language-plaintext highlighter-rouge">point_cloud.h</code>中定义了模板类<code class="language-plaintext highlighter-rouge">pcl::PointCloud</code>，用于表示点云；</li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pcl::PointCloud</code>模板类的数据成员定义如下：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PCLHeader</span> <span class="n">header</span><span class="p">;</span>                                          <span class="c1">// 点云报头，包含seq（序号）、stamp（时间戳）、frame_id（坐标系ID）数据成员</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;&gt;</span> <span class="n">points</span><span class="p">;</span>   <span class="c1">// 点云中的点</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">width</span><span class="p">;</span>                                            <span class="c1">// 点云宽度（如果点云按照图像形式组织，这里对应图像的列数，否则为点云中点的个数）</span>
 <span class="n">std</span><span class="o">::</span><span class="kt">uint32_t</span> <span class="n">height</span><span class="p">;</span>                                           <span class="c1">// 点云高度（如果点云按照图像形式组织，这里对应图像的行数，否则为1）</span>
 <span class="kt">bool</span> <span class="n">is_dense</span><span class="p">;</span>                                                  <span class="c1">// 点云中的点是否全部有效（即不存在Inf和NaN值）</span>
 <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span> <span class="n">sensor_origin_</span><span class="p">;</span>                                 <span class="c1">// 传感器位置（可选）</span>
 <span class="n">Eigen</span><span class="o">::</span><span class="n">Quaternionf</span> <span class="n">sensor_orientation_</span><span class="p">;</span>                         <span class="c1">// 传感器朝向（可选）</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pcl::PointCloud</code>模板类通过<code class="language-plaintext highlighter-rouge">std::vector</code>容器保存点云中的点，因此大部分函数成员都是对于<code class="language-plaintext highlighter-rouge">std::vector</code>容器中同名函数成员的直接封装，但是如果函数成员修改了<code class="language-plaintext highlighter-rouge">points</code>数据成员，则还需要同时维护<code class="language-plaintext highlighter-rouge">width</code>和<code class="language-plaintext highlighter-rouge">height</code>数据成员，<code class="language-plaintext highlighter-rouge">pcl::PointCloud</code>模板类的部分函数成员定义如下：</p>

    <ul>
      <li>
        <p>迭代器相关：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointT</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">aligned_allocator</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;&gt;</span> <span class="n">VectorType</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">VectorType</span><span class="o">::</span><span class="n">iterator</span> <span class="n">iterator</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="k">typename</span> <span class="n">VectorType</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">const_iterator</span><span class="p">;</span>
  <span class="kr">inline</span> <span class="n">iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">());</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>大小和容积相关：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">points</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">points</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">}</span>

  <span class="cm">/** \brief Resize the cloud
   * \param[in] n the new cloud size
   */</span>
  <span class="kr">inline</span> <span class="kt">void</span> <span class="n">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">points</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span> <span class="o">!=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">width</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
      <span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>元素访问：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kr">inline</span> <span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">n</span><span class="p">));</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">front</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">front</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">());</span> <span class="p">}</span>
  <span class="kr">inline</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">());</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>元素增加和删除：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/** \brief Insert a new point in the cloud, at the end of the container.
   * \note This breaks the organized structure of the cloud by setting the height to 1!
   * \param[in] pt the point to insert
   */</span>
  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">PointT</span><span class="o">&amp;</span> <span class="n">pt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>
    <span class="n">width</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/** \brief Removes all points in a cloud and sets the width and height to 0. */</span>
  <span class="kr">inline</span> <span class="kt">void</span> <span class="n">clear</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">points</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 除此之外还定义了insert()、erase()、swap()等函数成员</span>
  <span class="c1">// 由于使用较少并且重载形式较多，本文不再赘述</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>点云的定义：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud</span><span class="p">;</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">cloud</span><span class="p">.</span><span class="n">points</span><span class="p">;</span>
</code></pre></div>    </div>

    <ul>
      <li>为了方便计算，可以使用<code class="language-plaintext highlighter-rouge">std::vector&lt;Eigen::Vector3f&gt;</code>来保存点云中点的坐标；</li>
      <li><code class="language-plaintext highlighter-rouge">Eigen::Vector3f</code>不是固定大小可向量化的Eigen对象，因此不需要考虑内存对齐问题；</li>
    </ul>
  </li>
  <li>
    <p>点云的初始化：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud1</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud2</span><span class="p">;</span>
 <span class="n">x1</span> <span class="o">=</span> <span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
 <span class="n">y1</span> <span class="o">=</span> <span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
 <span class="n">z1</span> <span class="o">=</span> <span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">;</span>
 <span class="c1">// 以下两种方法均可以向点云中添加点，但是均会将有组织点云转换为无组织点云</span>
 <span class="c1">// 方法一：通过模板类的函数成员添加点，自动维护width和height数据成员</span>
 <span class="n">cloud2</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 <span class="c1">// 方法二：通过points数据成员的函数成员添加点</span>
 <span class="n">cloud2</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
 <span class="n">cloud2</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">cloud1</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>   <span class="c1">// C++11引入，执行效率高</span>
 <span class="c1">// 注意在添加完成后需要手动维护width和height数据成员</span>
 <span class="n">cloud2</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cloud2</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>点云与点云指针之间的赋值：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud1</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud2</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_ptr1</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_ptr2</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
 <span class="c1">// 浅拷贝，指向同一块内存地址</span>
 <span class="n">cloud1</span> <span class="o">=</span> <span class="n">cloud2</span><span class="p">;</span>
 <span class="n">cloud_ptr1</span> <span class="o">=</span> <span class="n">cloud_ptr2</span><span class="p">;</span>
 <span class="o">*</span><span class="n">cloud_ptr1</span> <span class="o">=</span> <span class="o">*</span><span class="n">cloud_ptr2</span><span class="p">;</span>
 <span class="c1">// 深拷贝，指向不同的内存地址</span>
 <span class="n">cloud1</span> <span class="o">=</span> <span class="o">*</span><span class="n">cloud_ptr1</span><span class="p">;</span>
 <span class="o">*</span><span class="n">cloud_ptr1</span> <span class="o">=</span> <span class="n">cloud1</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">copyPointCloud</span><span class="p">(</span><span class="n">cloud1</span><span class="p">,</span> <span class="n">cloud2</span><span class="p">);</span>  <span class="c1">// 深拷贝点云，重载形式较多，本文不再赘述</span>
 <span class="n">cloud_ptr1</span> <span class="o">=</span> <span class="n">cloud1</span><span class="p">.</span><span class="n">makeShared</span><span class="p">();</span>     <span class="c1">// 返回指向深拷贝对象的智能指针</span>
</code></pre></div>    </div>

    <ul>
      <li>
        <p>推荐使用<code class="language-plaintext highlighter-rouge">copyPointCloud()</code>函数深拷贝点云，定义如下：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">PointInT</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">PointOutT</span><span class="p">&gt;</span>
  <span class="kt">void</span> <span class="n">pcl</span><span class="o">::</span><span class="n">copyPointCloud</span><span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointInT</span><span class="o">&gt;&amp;</span> <span class="n">cloud_in</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointOutT</span><span class="o">&gt;&amp;</span> <span class="n">cloud_out</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate enough space and copy the basics</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">header</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">is_dense</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">is_dense</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">sensor_orientation_</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">sensor_orientation_</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">sensor_origin_</span> <span class="o">=</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">sensor_origin_</span><span class="p">;</span>
    <span class="n">cloud_out</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">isSamePointType</span><span class="o">&lt;</span><span class="n">PointInT</span><span class="p">,</span> <span class="n">PointOutT</span><span class="o">&gt;</span><span class="p">())</span>
      <span class="c1">// Copy the whole memory block</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cloud_out</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PointInT</span><span class="p">));</span>
    <span class="k">else</span>
      <span class="c1">// Iterate over each point</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">copyPoint</span><span class="p">(</span><span class="n">cloud_in</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cloud_out</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>推荐使用<code class="language-plaintext highlighter-rouge">makeShared()</code>函数成员创建指向深拷贝对象的智能指针，定义如下：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;&gt;</span> <span class="n">Ptr</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;&gt;</span> <span class="n">ConstPtr</span><span class="p">;</span>

  <span class="cm">/** \brief Copy the cloud to the heap and return a smart pointer
   * Note that deep copy is performed, so avoid using this function on non-empty clouds.
   * The changes of the returned cloud are not mirrored back to this one.
   * \return shared pointer to the copy of the cloud
   */</span>
  <span class="kr">inline</span> <span class="n">Ptr</span> <span class="nf">makeShared</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Ptr</span><span class="p">(</span><span class="k">new</span> <span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">PointT</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>点云拼接：</p>

    <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud_a</span><span class="p">,</span> <span class="n">cloud_b</span><span class="p">,</span> <span class="n">cloud_c</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="n">n_cloud_b</span><span class="p">;</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointNormal</span><span class="o">&gt;</span> <span class="n">p_n_cloud_c</span><span class="p">;</span>
 <span class="c1">// concatenate points</span>
 <span class="n">cloud_c</span>  <span class="o">=</span> <span class="n">cloud_a</span><span class="p">;</span>
 <span class="n">cloud_c</span> <span class="o">+=</span> <span class="n">cloud_b</span><span class="p">;</span>
 <span class="c1">// concatenate fields</span>
 <span class="n">pcl</span><span class="o">::</span><span class="n">concatenateFields</span><span class="p">(</span><span class="n">cloud_a</span><span class="p">,</span> <span class="n">n_cloud_b</span><span class="p">,</span> <span class="n">p_n_cloud_c</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>关于有组织点云（organized point cloud）：</p>

    <ul>
      <li>有组织点云指的是按照图像（或矩阵）形式组织的点云，通常来源于双目相机和飞行时间（Time of Flight，ToF）相机；
        <ul>
          <li>
            <p>有组织点云示例：</p>

            <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cloud1</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">640</span><span class="p">;</span>       <span class="c1">// Image-like organized structure, with 480 rows and 640 columns,</span>
  <span class="n">cloud1</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">480</span><span class="p">;</span>      <span class="c1">// thus 640*480=307200 points total in the dataset</span>
</code></pre></div>            </div>
          </li>
          <li>
            <p>无组织点云示例：</p>

            <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cloud2</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">307200</span><span class="p">;</span>
  <span class="n">cloud2</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// unorganized point cloud dataset with 307200 points</span>
</code></pre></div>            </div>
          </li>
        </ul>
      </li>
      <li>有组织点云的优点是可以通过相邻行列信息提高最近邻操作的效率，进而提高PCL中部分算法的计算速度；</li>
      <li>
        <p>可以使用<code class="language-plaintext highlighter-rouge">isOrganized()</code>函数成员判断点云是否有组织：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">cloud1</span><span class="p">.</span><span class="n">isOrganized</span><span class="p">();</span>       <span class="c1">// false</span>
  <span class="n">cloud2</span><span class="p">.</span><span class="n">isOrganized</span><span class="p">();</span>       <span class="c1">// true</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">isOrganized()</code>函数成员定义如下：</p>

        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cm">/** \brief Return whether a dataset is organized (e.g., arranged in a structured grid).
  * \note The height value must be different than 1 for a dataset to be organized.
  */</span>
  <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">isOrganized</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h2 id="滤波">滤波</h2>

<h3 id="passthrough">PassThrough</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/passthrough.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_filtered</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Create the filtering object</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PassThrough</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">pass</span><span class="p">;</span>
<span class="n">pass</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">pass</span><span class="p">.</span><span class="n">setFilterFieldName</span><span class="p">(</span><span class="s">"z"</span><span class="p">);</span>    <span class="c1">// 设置过滤字段</span>
<span class="n">pass</span><span class="p">.</span><span class="n">setFilterLimits</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>  <span class="c1">// 设置过滤范围，默认保留过滤范围内的点</span>
<span class="c1">// pass.setNegative(true);       // 反选，即保留过滤范围外的点</span>
<span class="n">pass</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_filtered</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="voxelgrid">VoxelGrid</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/voxel_grid.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_filtered</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Create the filtering object</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">VoxelGrid</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PCLPointCloud2</span><span class="o">&gt;</span> <span class="n">sor</span><span class="p">;</span>
<span class="n">sor</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">sor</span><span class="p">.</span><span class="n">setLeafSize</span><span class="p">(</span><span class="mf">0.01</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.01</span><span class="n">f</span><span class="p">,</span> <span class="mf">0.01</span><span class="n">f</span><span class="p">);</span>
<span class="n">sor</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_filtered</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="approximatevoxelgrid">ApproximateVoxelGrid</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/approximate_voxel_grid.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">input_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">filtered_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Filtering input scan to roughly 10% of original size to increase speed of registration.</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">ApproximateVoxelGrid</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">approximate_voxel_filter</span><span class="p">;</span>
<span class="n">approximate_voxel_filter</span><span class="p">.</span><span class="n">setLeafSize</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">);</span>
<span class="n">approximate_voxel_filter</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">input_cloud</span><span class="p">);</span>
<span class="n">approximate_voxel_filter</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">filtered_cloud</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="statisticaloutlierremoval">StatisticalOutlierRemoval</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/statistical_outlier_removal.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_filtered</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Create the filtering object</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">StatisticalOutlierRemoval</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">sor</span><span class="p">;</span>
<span class="n">sor</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">sor</span><span class="p">.</span><span class="n">setMeanK</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="n">sor</span><span class="p">.</span><span class="n">setStddevMulThresh</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">sor</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_filtered</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="radiusoutlierremoval">RadiusOutlierRemoval</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/radius_outlier_removal.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_filtered</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="n">pcl</span><span class="o">::</span><span class="n">RadiusOutlierRemoval</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">outrem</span><span class="p">;</span>
<span class="c1">// build the filter</span>
<span class="n">outrem</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">outrem</span><span class="p">.</span><span class="n">setRadiusSearch</span><span class="p">(</span><span class="mf">0.8</span><span class="p">);</span>
<span class="n">outrem</span><span class="p">.</span><span class="n">setMinNeighborsInRadius</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">outrem</span><span class="p">.</span><span class="n">setKeepOrganized</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// apply filter</span>
<span class="n">outrem</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_filtered</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="conditionalremoval">ConditionalRemoval</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/filters/conditional_removal.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_filtered</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="n">pcl</span><span class="o">::</span><span class="n">ConditionAnd</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">range_cond</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ConditionAnd</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">());</span>
<span class="n">range_cond</span><span class="o">-&gt;</span><span class="n">addComparison</span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">ConstPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonOps</span><span class="o">::</span><span class="n">GT</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)));</span>
<span class="n">range_cond</span><span class="o">-&gt;</span><span class="n">addComparison</span><span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">ConstPtr</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">FieldComparison</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"z"</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">ComparisonOps</span><span class="o">::</span><span class="n">LT</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)));</span>
<span class="c1">// build the filter</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">ConditionalRemoval</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">condrem</span><span class="p">;</span>
<span class="n">condrem</span><span class="p">.</span><span class="n">setCondition</span><span class="p">(</span><span class="n">range_cond</span><span class="p">);</span>
<span class="n">condrem</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">condrem</span><span class="p">.</span><span class="n">setKeepOrganized</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// apply filter</span>
<span class="n">condrem</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">*</span><span class="n">cloud_filtered</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="配准">配准</h2>

<h3 id="icp">ICP</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/registration/icp.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_in</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud_out</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="n">pcl</span><span class="o">::</span><span class="n">IterativeClosestPoint</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">icp</span><span class="p">;</span>
<span class="n">icp</span><span class="p">.</span><span class="n">setInputSource</span><span class="p">(</span><span class="n">cloud_in</span><span class="p">);</span>
<span class="n">icp</span><span class="p">.</span><span class="n">setInputTarget</span><span class="p">(</span><span class="n">cloud_out</span><span class="p">);</span>

<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">Final</span><span class="p">;</span>
<span class="n">icp</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Final</span><span class="p">)</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"has converged:"</span> <span class="o">&lt;&lt;</span> <span class="n">icp</span><span class="p">.</span><span class="n">hasConverged</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" score: "</span> <span class="o">&lt;&lt;</span>
<span class="n">icp</span><span class="p">.</span><span class="n">getFitnessScore</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">icp</span><span class="p">.</span><span class="n">getFinalTransformation</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="ndt">NDT</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/registration/ndt.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">target_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">input_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">filtered_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>

<span class="c1">// Initializing Normal Distributions Transform (NDT).</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">NormalDistributionsTransform</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">ndt</span><span class="p">;</span>

<span class="c1">// Setting scale dependent NDT parameters</span>
<span class="c1">// Setting minimum transformation difference for termination condition.</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setTransformationEpsilon</span><span class="p">(</span><span class="mf">0.01</span><span class="p">);</span>
<span class="c1">// Setting maximum step size for More-Thuente line search.</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setStepSize</span><span class="p">(</span><span class="mf">0.1</span><span class="p">);</span>
<span class="c1">// Setting Resolution of NDT grid structure (VoxelGridCovariance).</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setResolution</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>

<span class="c1">// Setting max number of registration iterations.</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setMaximumIterations</span><span class="p">(</span><span class="mi">35</span><span class="p">);</span>

<span class="c1">// Setting point cloud to be aligned.</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setInputSource</span><span class="p">(</span><span class="n">filtered_cloud</span><span class="p">);</span>
<span class="c1">// Setting point cloud to be aligned to.</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">setInputTarget</span><span class="p">(</span><span class="n">target_cloud</span><span class="p">);</span>

<span class="c1">// Set initial alignment estimate found using robot odometry.</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisf</span> <span class="nf">init_rotation</span><span class="p">(</span><span class="mf">0.6931</span><span class="p">,</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3f</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">());</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Translation3f</span> <span class="nf">init_translation</span><span class="p">(</span><span class="mf">1.79387</span><span class="p">,</span> <span class="mf">0.720047</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span> <span class="n">init_guess</span> <span class="o">=</span> <span class="p">(</span><span class="n">init_translation</span> <span class="o">*</span> <span class="n">init_rotation</span><span class="p">).</span><span class="n">matrix</span><span class="p">();</span>

<span class="c1">// Calculating required rigid transform to align the input cloud to the target cloud.</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">output_cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">ndt</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="o">*</span><span class="n">output_cloud</span><span class="p">,</span> <span class="n">init_guess</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Normal Distributions Transform has converged:"</span> <span class="o">&lt;&lt;</span> <span class="n">ndt</span><span class="p">.</span><span class="n">hasConverged</span><span class="p">()</span>
          <span class="o">&lt;&lt;</span> <span class="s">" score: "</span> <span class="o">&lt;&lt;</span> <span class="n">ndt</span><span class="p">.</span><span class="n">getFitnessScore</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

<span class="c1">// Transforming unfiltered, input cloud using found transform.</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">transformPointCloud</span><span class="p">(</span><span class="o">*</span><span class="n">input_cloud</span><span class="p">,</span> <span class="o">*</span><span class="n">output_cloud</span><span class="p">,</span> <span class="n">ndt</span><span class="p">.</span><span class="n">getFinalTransformation</span><span class="p">());</span>
</code></pre></div></div>

<h2 id="kdtree">KdTree</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/kdtree/kdtree_flann.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">KdTreeFLANN</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">kdtree</span><span class="p">;</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span> <span class="n">searchPoint</span><span class="p">;</span>

<span class="n">kdtree</span><span class="p">.</span><span class="n">setInputCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>

<span class="c1">// K nearest neighbor search</span>
<span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pointIdxKNNSearch</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">pointKNNSquaredDistance</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>

<span class="c1">// 返回值为找到最近邻的个数</span>
<span class="n">kdtree</span><span class="p">.</span><span class="n">nearestKSearch</span><span class="p">(</span><span class="n">searchPoint</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">pointIdxKNNSearch</span><span class="p">,</span>
                      <span class="n">pointKNNSquaredDistance</span><span class="p">);</span>
<span class="c1">// 最近邻点</span>
<span class="c1">// (*cloud)[pointIdxKNNSearch[i]]</span>

<span class="c1">// Neighbors within radius search</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pointIdxRadiusSearch</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">pointRadiusSquaredDistance</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>

<span class="c1">// 返回值为找到最近邻的个数</span>
<span class="n">kdtree</span><span class="p">.</span><span class="n">radiusSearch</span><span class="p">(</span><span class="n">searchPoint</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">pointIdxRadiusSearch</span><span class="p">,</span>
                    <span class="n">pointRadiusSquaredDistance</span><span class="p">);</span>
<span class="c1">// 最近邻点</span>
<span class="c1">// (*cloud)[pointIdxRadiusSearch[i]]</span>
</code></pre></div></div>

<h2 id="输入输出">输入输出</h2>

<h3 id="pcd文件格式">PCD文件格式</h3>

<ol>
  <li>
    <p>文件头需要<strong>严格按照</strong>以下顺序：</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> VERSION
 FIELDS
 SIZE
 TYPE
 COUNT
 WIDTH
 HEIGHT
 VIEWPOINT
 POINTS
 DATA
</code></pre></div>    </div>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">VERSION</code>：PCD文件版本，PCL要求0.7；</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">FIELDS</code>：点的每个维度对应的数据含义：</p>

        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  FIELDS x y z                                # XYZ data
  FIELDS x y z rgb                            # XYZ + colors
  FIELDS x y z normal_x normal_y normal_z     # XYZ + surface normals
  FIELDS j1 j2 j3                             # moment invariants
</code></pre></div>        </div>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">SIZE</code>：点的每个维度占据的字节数：</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">数据类型</th>
              <th style="text-align: left">字节数</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">unsigned char / char</td>
              <td style="text-align: left">1</td>
            </tr>
            <tr>
              <td style="text-align: left">unsigned short / short</td>
              <td style="text-align: left">2</td>
            </tr>
            <tr>
              <td style="text-align: left">unsigned int / int / float</td>
              <td style="text-align: left">4</td>
            </tr>
            <tr>
              <td style="text-align: left">double</td>
              <td style="text-align: left">8</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">TYPE</code>：点的每个维度对应的数据类型：</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">数据类型</th>
              <th style="text-align: left">字符表示</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left">有符号：int8（char）、int16（short）、int32（int）</td>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">I</code></td>
            </tr>
            <tr>
              <td style="text-align: left">无符号：uint8（unsigned char）、uint16（unsigned short）、uint32（unsigned int）</td>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">U</code></td>
            </tr>
            <tr>
              <td style="text-align: left">float</td>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">F</code></td>
            </tr>
          </tbody>
        </table>
      </li>
      <li><code class="language-plaintext highlighter-rouge">COUNT</code>：点的每个维度包含的元素个数，默认为1；</li>
      <li><code class="language-plaintext highlighter-rouge">WIDTH</code>：点云的列数，对于无组织点云为点的总数；</li>
      <li><code class="language-plaintext highlighter-rouge">HEIGHT</code>：点云的行数，对于无组织点云为1；</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">VIEWPOINT</code>：点云的采集视角，使用向量表示平移，使用四元数表示旋转，默认旋转和平移为0：</p>

        <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  tx ty tz qw qx qy qz
</code></pre></div>        </div>
      </li>
      <li><code class="language-plaintext highlighter-rouge">POINTS</code>：点的总数；</li>
      <li>
        <p><code class="language-plaintext highlighter-rouge">DATA</code>：存储方式：</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: left">存储方式</th>
              <th style="text-align: left">说明</th>
              <th style="text-align: left">优势</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ascii</code></td>
              <td style="text-align: left">使用ASCII码存储</td>
              <td style="text-align: left">简洁直观，便于第三方软件读取</td>
            </tr>
            <tr>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">binary</code></td>
              <td style="text-align: left">使用二进制存储，内存拷贝</td>
              <td style="text-align: left">读取速度最快</td>
            </tr>
            <tr>
              <td style="text-align: left"><code class="language-plaintext highlighter-rouge">binary_compressed</code></td>
              <td style="text-align: left">使用二进制存储，LZF算法压缩</td>
              <td style="text-align: left">压缩后大小为<code class="language-plaintext highlighter-rouge">binary</code>的30%-60%，读取时需要解压缩</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>数据每个点占一行，使用<code class="language-plaintext highlighter-rouge">nan</code>表示NaN：</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> p_1
 p_2
 p_3
 p_4
 ...

 p_n
</code></pre></div>    </div>
  </li>
  <li>
    <p>文件头示例：</p>

    <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code> # .PCD v.7 - Point Cloud Data file format
 VERSION .7
 FIELDS x y z rgb
 SIZE 4 4 4 4
 TYPE F F F F
 COUNT 1 1 1 1
 WIDTH 213
 HEIGHT 1
 VIEWPOINT 0 0 0 1 0 0 0
 POINTS 213
 DATA ascii
 0.93773 0.33763 0 4.2108e+06
 0.90805 0.35641 0 4.2108e+06
 0.81915 0.32 0 4.2108e+06
 0.97192 0.278 0 4.2108e+06
 0.944 0.29474 0 4.2108e+06
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="输入">输入</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="nf">cloud</span><span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">loadPCDFile</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"test_pcd.pcd"</span><span class="p">,</span> <span class="o">*</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Loaded "</span> <span class="o">&lt;&lt;</span> <span class="n">cloud</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">*</span> <span class="n">cloud</span><span class="o">-&gt;</span><span class="n">height</span>
          <span class="o">&lt;&lt;</span> <span class="s">" data points from test_pcd.pcd with the following fields: "</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="输出">输出</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pcl/io/pcd_io.h&gt;</span><span class="cp">
</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">cloud</span><span class="p">;</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">io</span><span class="o">::</span><span class="n">savePCDFileASCII</span><span class="p">(</span><span class="s">"test_pcd.pcd"</span><span class="p">,</span> <span class="n">cloud</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Saved "</span> <span class="o">&lt;&lt;</span> <span class="n">cloud</span><span class="p">.</span><span class="n">size</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" data points to test_pcd.pcd."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="可视化">可视化</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;::</span><span class="n">Ptr</span> <span class="n">cloud</span><span class="p">;</span>
<span class="c1">//... populate cloud</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">CloudViewer</span> <span class="nf">viewer</span><span class="p">(</span><span class="s">"Simple Cloud Viewer"</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">showCloud</span><span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">viewer</span><span class="p">.</span><span class="n">wasStopped</span><span class="p">())</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">-</code>来增大和减小显示点的大小；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">Alt</code>+<code class="language-plaintext highlighter-rouge">+</code>和<code class="language-plaintext highlighter-rouge">Alt</code>+<code class="language-plaintext highlighter-rouge">-</code>来放大和缩小画面；</li>
  <li>
    <p>在可视化界面中使用<code class="language-plaintext highlighter-rouge">1</code>-<code class="language-plaintext highlighter-rouge">5</code>设置点云颜色：</p>

    <ul>
      <li><code class="language-plaintext highlighter-rouge">1</code>：单色；</li>
      <li><code class="language-plaintext highlighter-rouge">2</code>：按照x坐标着色；</li>
      <li><code class="language-plaintext highlighter-rouge">3</code>：按照y坐标着色；</li>
      <li><code class="language-plaintext highlighter-rouge">4</code>：按照z坐标着色；</li>
      <li><code class="language-plaintext highlighter-rouge">5</code>：按照反射强度着色；</li>
    </ul>
  </li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">g</code>显示或隐藏坐标轴；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">u</code>显示或隐藏颜色图；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">o</code>打开或关闭正交投影；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">f</code>拉近到光标所在位置；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">r</code>重置相机视角；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">j</code>截图；</li>
  <li>在可视化界面中使用<code class="language-plaintext highlighter-rouge">e</code>退出；</li>
</ol>

<h2 id="资料">资料</h2>

<h3 id="网站">网站</h3>

<ol>
  <li><a href="https://pointclouds.org">Point Cloud Library</a></li>
  <li><a href="https://pcl.readthedocs.io/projects/tutorials/en/master/">pcl</a></li>
  <li><a href="https://pcl-docs.readthedocs.io/en/latest/">pcl-docs</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/268524083">PCL(Point Cloud Library)学习指南&amp;资料推荐（2023版）-双愚的文章-知乎</a></li>
  <li><a href="https://www.bilibili.com/video/BV1HS4y1y7AB">PCL(Point Cloud Library)学习入门指南&amp;代码实践(最新版)</a></li>
  <li><a href="https://segmentfault.com/a/1190000007125502">pcl常用小知识</a></li>
</ol>

<h3 id="github">GitHub</h3>

<ol>
  <li><a href="https://github.com/HuangCongQing/pcl-learning">HuangCongQing/pcl-learning</a></li>
  <li><a href="https://github.com/MNewBie/PCL-Notes">MNewBie/PCL-Notes</a></li>
  <li><a href="https://github.com/methylDragon/pcl-ros-tutorial">methylDragon/pcl-ros-tutorial</a></li>
  <li><a href="https://github.com/LarryDong/csdn_codes">LarryDong/csdn_codes</a></li>
</ol>

<h2 id="参考">参考</h2>

<ol>
  <li><a href="https://stackoverflow.com/questions/15999331/how-can-i-change-rgb-values-of-pclpointxyzrgba">pcl::PointXYZRGBA-Stack Overflow</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/458373010">PCL新增自定义点类型-飞我执笔的文章-知乎</a></li>
  <li><a href="https://eigen.tuxfamily.org/dox/group__TopicStlContainers.html">Using STL Containers with Eigen</a></li>
  <li><a href="https://blog.csdn.net/tfb760/article/details/115101393">点云与点云指针之间的赋值1-CSDN博客</a></li>
  <li><a href="https://blog.csdn.net/h287850870/article/details/80988552">点云与点云指针之间的赋值2-CSDN博客</a></li>
  <li><a href="https://blog.csdn.net/h287850870/article/details/81184397">点云与点云指针之间的赋值3-CSDN博客</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/442236714">关于PCL库中makeshared转换智能指针的问题-小透明的文章-知乎</a></li>
  <li><a href="https://blog.csdn.net/qq_39779233/article/details/106985091">pcl_viewer-CSDN博客</a></li>
</ol>

  </div>

  
  
<script src="https://utteranc.es/client.js"
        repo="YWpepper/YWpepper.github.io"
        issue-term="title"
        label="comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


  
</article>

<div class="pagination">
  
    <span class="prev" >
      <a href="http://localhost:4000/screen-record/">
        ← 上一篇
      </a>
    </span>
  
  
    <span class="next" >
      <a href="http://localhost:4000/colmap-note/">
        下一篇 →
      </a>
    </span>
  
</div>
      </div>
    </div>

    

  </body>

  
  <script>
    document.getElementById("main").classList.add("withtoc");
  </script>
  

  <div class="wrapper-footer-mobile">
    <footer class="footer">
      <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  
  
  

  

  

  

  

  
  <li><a href="https://github.com/zxl19" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

</ul>



<p>Copyright © 2020-2025 zxl19. All Rights Reserved.</p>

    </footer>


</html>
