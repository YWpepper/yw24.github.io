---
layout: post
title: C++标准模板库学习笔记
date: 2021-09-19
author: zxl19
tags: [C++, Note]
comments: true
toc: true
pinned: false
---

我的C++标准模板库（Standard Template Library，STL）学习笔记。

<!-- more -->

## STL Hello World

C++标准模板库的核心包括以下三个组件：

1. **容器（Containers）**：容器是容纳、包含一类元素的对象。容器类库中包括7种基本容器，可以分为两种基本类型：顺序容器（sequence container）和关联容器（associative container）；

    - **顺序容器**：将一组具有相同类型的元素以严格线性形式组织起来，向量、双端队列和列表容器就属于这一种；
    - **关联容器**：具有根据一组索引来快速提取元素的能力，集合和映射容器就属于这一种；
    - STL中各容器头文件和所属概念：

    | 容器名 | 中文名 | 头文件 | 所属概念 |
    | :---- | :---- | :---- | :---- |
    | vector | 向量 | `#include <vector>` | 随机访问容器，顺序容器 |
    | deque | 双端队列 | `#include <deque>` | 随机访问容器，顺序容器 |
    | list | 列表 | `#include <list>` | 可逆容器，顺序容器 |
    | set | 集合 | `#include <set>` | 可逆容器，关联容器 |
    | multiset | 多重集合 | `#include <set>` | 可逆容器，关联容器 |
    | map | 映射 | `#include <map>` | 可逆容器，关联容器 |
    | multimap | 多重映射 | `#include <map>` | 可逆容器，关联容器 |

2. **算法（Algorithms）**：算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作；
3. **迭代器（Iterators）**：迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。迭代器是泛化的指针；

## 容器

符号说明：

- S：容器类型；
- s：S类型的实例；
- T：元素类型；
- t：T类型的实例；
- n：整型数据；
- p：指向s中元素的迭代器；
- q：任何指向T类型元素的输入迭代器（未必指向S中的元素，也未必具有S::iterator类型）；

### 容器基本功能

```cpp
// 调用默认构造函数初始化
S s1, s2;
// op为比较运算符，对两个容器之间的元素按字典顺序进行比较
s1 op s2
// 返回迭代器
S::iterator s1.begin()      // 指向容器第一个元素
S::iterator s1.end()        // 指向容器最后一个元素的下一个位置
// 成员函数
void s1.clear()
bool s1.empty()
size_t s1.size()
void s1.swap(s2)
```

### 顺序容器

包括vector、deque、list，常用基本功能如下所示：

```cpp
// 构造函数
S s(n, t)                   // 构造一个由n个t元素构成的容器实例s
S s(n)                      // 构造一个有n个元素的容器实例s，每个元素都是T()
S s(q1, q2)                 // 使用将迭代器[q1, q2)区间内的数据作为s的元素构造s
// 赋值函数
s.assign(n, t)              // 赋值后的容器由n个t元素构成
s.assign(n)                 // 赋值后的容器有n个t元素的容器实例s，每个元素都是T()
s.assign(q1, q2)            // 赋值后的容器的元素为[q1, q2)区间内的数据
// 改变容器的大小
void s.resize(n)
// 首尾元素的直接访问
value_type& s.front()
value_type& s.back()
// 在容器尾部插入、删除元素
void s.push_back(t)
void s.pop_back()
// 在容器头部插入、删除元素（deque、list）
void s.push_front(t)
void s.pop_front()
// 在容器头部插入、删除元素（vector）
void s.insert(s.begin())
void s.erase(s.begin())
```

三种顺序容器的特性不同，需要根据实际应用场景进行选择，各容器适合的场景如下表所示：

| 容器 | 随机访问 | 扩展方式 |
| :---- | :---- | :---- |
| vector | 需要大量 | 只需要向容器尾部加入新的元素 |
| deque | 需要少量 | 需要在容器两端插入或删除元素 |
| list | 不需要 | 需要在中间位置插入或删除元素 |

详细比较可参考《C++语言程序设计》P422表10-2。

#### 向量`vector`

1. `size()`和`capacity()`的区别：

    ```cpp
    size_t s.size()         // 返回向量容器的大小
    void s.resize(n)        // 改变向量容器的大小
    size_t s.capacity()     // 返回向量容器的容量
    void s.reserve(n)       // 改变向量容器的容量
    ```

2. 访问元素方式：

    ```cpp
    s[i]                    // 无越界检查，需要确保下标不超过容器容量
    s.at(i)                 // 有越界检查，下标越界时会抛出std::out_of_range异常
    ```

3. `push_back()`和`emplace_back()`的区别：

    ```cpp
    void s.push_back()      // 在容器尾部添加一个元素，创建+拷贝或移动（拷贝优先）
    void s.emplace_back()   // 在容器尾部生成一个元素，直接在容器中创建，C++11引入，执行效率高
    ```

### 顺序容器的适配器

以顺序容器为基础构建一些常用数据结构，STL提供的容器适配器栈（stack）和队列（queue），就是对顺序容器的封装。

1. 栈：**先进后出（FILO）**，即最先被压入栈的元素总是最后被弹出；
2. 队列：**先进先出（FIFO）**，即最先入队的元素总是最先出队；

#### 顺序容器适配器的基本功能

```cpp
// op为比较运算符，对两个容器之间的元素按字典顺序进行比较
s1 op s2
// 成员函数
size_t s.size()
bool s.empty()
void s.push()
void s.pop()
```

容器适配器不支持迭代器，因为它们不允许对任意元素进行访问。

#### 栈`stack`

对于栈来说，只有栈顶的元素是可以访问到的：

```cpp
value_type& s.top()
```

#### 队列`queue`

对于队列来说，只有队头和队尾的元素是可以访问到的：

```cpp
value_type& s.front()
value_type& s.back()
```

### 关联容器

| 类型 | 简单关联容器 | 二元关联容器 |
| :---- | :---- | :---- |
| 单重关联容器 | 集合（set） | 映射（map） |
| 多重关联容器 | 多重集合（multiset） | 多重映射（multimap） |

1. 简单关联容器：只有一个类型参数，该类型既是键类型，又是容器类型；
2. 二元关联容器：有两个类型参数，前一个是键类型，后一个是附加数据的类型；

#### 二元组`pair`

二元关联容器的元素类型是键类型和附加数据类型的组合，这种组合类型可以用一个二元组来表示。

使用时需要引入头文件：

```cpp
#include <utility>
```

##### 二元组实现

```cpp
template<class T1, class T2>
struct pair {
    T1 first;                                               // 二元组的第一元
    T2 second;                                              // 二元组的第二元
    pair();                                                 // 默认构造函数
    pair(const T1 &x, const T2 &y);                         // 构造first = x, second = y的二元组
    template<class U, class V> pair(const pair<U, V> &p);   // 拷贝构造函数
}
```

### 无序关联式容器

无序关联式容器，又称哈希容器，C++11引入。

TODO

### 字符串`string`

#### 操作符

| 操作符 | 示例 | 含义 |
| :---- | :---- | :----|
| + | `s + t` | 将串`s`和`t`连接成一个新串 |
| = | `s = t` | 用t更新s |
| += | `s += t` | 等价于`s = s + t` |
| == | `s == t` | 判断`s`与`t`是否相等 |
| != | `s != t` | 判断`s`与`t`是否不等 |
| < | `s < t` | 判断`s`是否小于`t` |
| <= | `s <= t` | 判断`s`是否小于或等于`t` |
| > | `s > t` | 判断`s`是否大于`t` |
| >= | `s >= t` | 判断`s`是否大于或等于`t` |
| [] | `s[i]` | 访问串中下标为`i`的字符，也可通过成员函数`s.at(i)` |

#### 常用基本功能

```cpp
size_t s.size()
bool s.empty()
void s.push_back(char c)                        // 追加单个字符
void s.pop_back()
string s.substr(size_t pos, size_t len)         // 取子字符串
void s.append(const string& str)                // 追加字符串
```

#### 遍历字符串

```cpp
for (size_t i = 0; i < s.size(); i++)           // 常规方式
for (char c : s)                                // C++11引入
for (char& c : s)                               // C++11引入，速度更快
```

### 链表

#### 链表实现

```cpp
struct ListNode {
    int val;                                    // 当前节点的值
    struct ListNode *next;                      // 指向下一个节点的指针
    ListNode(int x) : val(x), next(nullptr) {}  // 初始化当前结点值为x，指针为空
};
```

### 二叉树

#### 二叉树实现

```cpp
struct TreeNode {
    int val;                                                    // 当前节点的值
    TreeNode *left;                                             // 左指针
    TreeNode *right;                                            // 右指针
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  // 初始化当前结点值为x，左右指针为空
};
```

#### 遍历方式

1. **前序遍历（DLR）**：根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；
2. **中序遍历（LDR）**：根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面；
3. **后序遍历（LRD）**：根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面；

```cpp
// 前序遍历
void pre_order(TreeNode* Node) {
    if (Node == nullptr)
        return;
    std::cout << "Node Data: " << Node->data << std::endl;
    pre_order(Node->left);
    pre_order(Node->right);
}
// 中序遍历
void middle_order(TreeNode* Node) {
    if (Node == nullptr)
        return;
    middle_order(Node->left);
    std::cout << "Node Data: " << Node->data << std::endl;
    middle_order(Node->right);
}
// 后序遍历
void post_order(TreeNode* Node) {
    if (Node == nullptr)
        return;
    post_order(Node->left);
    post_order(Node->right);
    std::cout << "Node Data: " << Node->data << std::endl;
}
```

## 算法

### 算法分类

一般来说，STL的算法可以分为4大类：

1. **不可变序列算法**：不直接修改所操作的容器内容的算法；
2. **可变序列算法**：可以修改所操作的容器内容的算法；
3. **排序和搜索算法**：对序列元素进行比较操作的算法；
4. **数值算法**：4个通用数值算法；

使用时需要引入头文件：

```cpp
#include <algorithm>                            // 大部分算法
#include <numeric>                              // 数值算法
```

### 不可变序列算法

TODO

### 可变序列算法

```cpp
void reverse(s.begin(), s.end());               // 反转区间元素次序
void swap(s.at(i), s.at(j));                    // 交换（对调）元素
```

### 排序和搜索算法

```cpp
void sort(s.begin(), s.end());                  // 对区间元素进行排序
bool binary_search(s.begin(), s.end(), t);      // 在有序区间内按照二分查找方法查找是否存在与某一特定值相等的元素
pair<S::iterator, S::iterator> equal_range(s.begin(), s.end(), t);  // 在有序区间内按照二分查找方法查找是否存在与某一特定值相等的元素，并返回一个上下限区间
value_type& min(s.at(i), s.at(j));              // 返回最小值元素
value_type& max(s.at(i), s.at(j));              // 返回最大值元素
S::iterator min_element(s.begin(), s.end());    // 返回最小值元素所在位置
S::iterator max_element(s.begin(), s.end());    // 返回最大值元素所在位置
```

### 数值算法

TODO

## 参考

1. 《C++语言程序设计》
2. 《labuladong的算法小抄》
3. [C++教程-菜鸟教程](https://www.runoob.com/cplusplus/cpp-tutorial.html)
4. [STL教程-C语言中文网](http://c.biancheng.net/stl/)
5. [字符串1-CSDN博客](https://blog.csdn.net/qq_38537503/article/details/106279850)
6. [字符串2-CSDN博客](https://blog.csdn.net/qq_42270373/article/details/84589231)
7. [字符串3-CSDN博客](https://blog.csdn.net/weixin_36670529/article/details/108401528)
8. [链表-腾讯云](https://cloud.tencent.com/developer/article/1656468)
9. [二叉树-CSDN博客](https://blog.csdn.net/u013834525/article/details/80421684)
