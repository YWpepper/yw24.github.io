---
layout: post
title: PCL库学习笔记
date: 2021-11-28
author: zxl19
tags: [C++, PCL, Note]
comments: true
toc: true
pinned: false
---

我的点云库（Point Cloud Library，PCL）学习笔记。

<!-- more -->

## PCL Hello World

### 模块

按照功能，PCL包含以下几个模块：

1. 滤波（Filters）；
2. 特征（Features）；
3. 关键点（Keypoints）；
4. 配准（Registration）；
5. KdTree；
6. 八叉树（Octree）；
7. 分割（Segmentation）；
8. 采样一致（Sample Consensus）；
9. 表面（Surface）；
10. 深度图（Range Image）；
11. 输入输出（I/O）；
12. 可视化（Visualization）；
13. Common；
14. Search；

### CMakeLists

```cmake
cmake_minimum_required(VERSION 2.6 FATAL_ERROR)
project(MY_GRAND_PROJECT)
find_package(PCL 1.3 REQUIRED COMPONENTS common io)
include_directories(${PCL_INCLUDE_DIRS})
link_directories(${PCL_LIBRARY_DIRS})
add_definitions(${PCL_DEFINITIONS})
add_executable(pcd_write_test pcd_write.cpp)
target_link_libraries(pcd_write_test ${PCL_LIBRARIES})
```

## 基础数据结构

### 点

1. PCL在`point_types.hpp`中定义了支持的点的类型，以下为包含XYZ坐标的点的类型：

    ```cpp
    // Define all point types that include XYZ data
    #define PCL_XYZ_POINT_TYPES   \
      (pcl::PointXYZ)             \
      (pcl::PointXYZI)            \
      (pcl::PointXYZL)            \
      (pcl::PointXYZRGBA)         \
      (pcl::PointXYZRGB)          \
      (pcl::PointXYZRGBL)         \
      (pcl::PointXYZLAB)          \
      (pcl::PointXYZHSV)          \
      (pcl::InterestPoint)        \
      (pcl::PointNormal)          \
      (pcl::PointXYZRGBNormal)    \
      (pcl::PointXYZINormal)      \
      (pcl::PointXYZLNormal)      \
      (pcl::PointWithRange)       \
      (pcl::PointWithViewpoint)   \
      (pcl::PointWithScale)       \
      (pcl::PointSurfel)          \
      (pcl::PointDEM)
    ```

2. PCL对于点的类型进行内存对齐，使用SSE（Streaming SIMD Extensions）加速，以`pcl::PointXYZ`和`pcl::PointXYZI`为例：

    ```cpp
    // PointXYZ
    union {
      float data[4];
      struct {
        float x;
        float y;
        float z;
      };
    };
    // PointXYZI
    union {
      float data[4];
      struct {
        float x;
        float y;
        float z;
      };
    };
    union {
      struct {
        float intensity;
      };
      float data_c[4];
    };
    ```

    可以看出，点的坐标为float类型。

3. 点的定义和初始化：

    ```cpp
    pcl::PointXYZ pt;
    // 生成随机点
    pt.x = 1024.0f * rand() / (RAND_MAX + 1.0f);
    pt.y = 1024.0f * rand() / (RAND_MAX + 1.0f);
    pt.z = 1024.0f * rand() / (RAND_MAX + 1.0f);
    ```

4. PCL在`point_types.hpp`中定义了与Eigen相互转换的函数：

    ```cpp
    #define PCL_ADD_EIGEN_MAPS_POINT4D \
      inline pcl::Vector3fMap getVector3fMap () { return (pcl::Vector3fMap (data)); } \
      inline pcl::Vector3fMapConst getVector3fMap () const { return (pcl::Vector3fMapConst (data)); } \
      inline pcl::Vector4fMap getVector4fMap () { return (pcl::Vector4fMap (data)); } \
      inline pcl::Vector4fMapConst getVector4fMap () const { return (pcl::Vector4fMapConst (data)); } \
      inline pcl::Array3fMap getArray3fMap () { return (pcl::Array3fMap (data)); } \
      inline pcl::Array3fMapConst getArray3fMap () const { return (pcl::Array3fMapConst (data)); } \
      inline pcl::Array4fMap getArray4fMap () { return (pcl::Array4fMap (data)); } \
      inline pcl::Array4fMapConst getArray4fMap () const { return (pcl::Array4fMapConst (data)); }
    ```

    示例：

    ```cpp
    pcl::PointXYZ pt;
    Eigen::Vector3f vec;
    pt.getVector3fMap() = vec;
    vec = pt.getVector3fMap();
    ```

    可以看出，`getVector3fMap()`函数返回的是引用，可以作为等号左值和等号右值使用。

### 点云

1. `pcl::PointCloud`是一个模板类，包含了以下数据成员：

    ```cpp
    int width;                                  // 点云列数
    int height;                                 // 点云行数
    std::vector<PointT> points;                 // 点云中的点
    bool is_dense;                              // 点云中的点是否有Inf和NaN值
    Eigen::Vector4f sensor_origin_;             // 传感器位置（可选）
    Eigen::Quaternionf sensor_orientation_;     // 传感器朝向（可选）
    ```

2. 点云的定义：

    ```cpp
    pcl::PointCloud<pcl::PointXYZ> cloud;
    std::vector<pcl::PointXYZ> data = cloud.points;
    ```

    也可以使用`std::vector<Eigen::Vector3f>`来保存点云中点的坐标，这样更加方便计算；也可以使用`Eigen::Matrix<Eigen::Vector3f, N, 1>`来保存点云中点的坐标，这样可以实现内存对齐，方便使用SSE加速。

3. 点云的初始化：

    ```cpp
    pcl::PointCloud<pcl::PointXYZ> cloud1;
    pcl::PointCloud<pcl::PointXYZ> cloud2;
    cloud2.push_back(cloud1.points[i]);
    x1 = cloud1.points[i].x;
    y1 = cloud1.points[i].y;
    z1 = cloud1.points[i].z;
    ```

    `pcl::PointCloud`模板类的成员函数`push_back()`定义如下：

    ```cpp
    /** \brief Insert a new point in the cloud, at the end of the container.
      * \note This breaks the organized structure of the cloud by setting the height to 1!
      * \param[in] pt the point to insert
      */
    inline void push_back(const PointT& pt) {
      points.push_back(pt);
      width = static_cast<uint32_t>(points.size());
      height = 1;
    }
    ```

    可以看出，该成员函数首先调用`std::vector`模板类的成员函数`push_back()`向`points`数据成员中添加点，之后根据点云中点的数量修改`width`和`height`数据成员。因此在向点云中添加点时，可以调用`std::vector`模板类的成员函数直接对于`points`数据成员进行操作，之后根据点云中点的数量修改`width`和`height`数据成员，这与调用`pcl::PointCloud`模板类的成员函数`push_back()`是等效的。但是上述操作均会修改`width`和`height`数据成员，将有组织点云转换为无组织点云。

4. 点云与点云指针转换：

    ```cpp
    pcl::PointCloud<pcl::PointXYZ> cloud1;
    pcl::PointCloud<pcl::PointXYZ> cloud2;
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr1(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr2(new pcl::PointCloud<pcl::PointXYZ>);
    cloud1 = cloud2;                            // 浅拷贝，指向同一块内存地址
    cloud1 = *cloud_ptr1;                       // 深拷贝，指向不同的内存地址
    *cloud_ptr1 = cloud1;                       // 深拷贝，指向不同的内存地址
    cloud_ptr1 = cloud_ptr2;                    // 浅拷贝，指向同一块内存地址
    *cloud_ptr1 = *cloud_ptr2;                  // 浅拷贝，指向同一块内存地址
    cloud_ptr1 = cloud1.makeShared();           // 返回指向深拷贝对象的智能指针
    ```

5. 点云拼接：

    ```cpp
    pcl::PointCloud<pcl::PointXYZ> cloud_a, cloud_b, cloud_c;
    pcl::PointCloud<pcl::Normal> n_cloud_b;
    pcl::PointCloud<pcl::PointNormal> p_n_cloud_c;
    // concatenate points
    cloud_c  = cloud_a;
    cloud_c += cloud_b;
    // concatenate fields
    pcl::concatenateFields(cloud_a, n_cloud_b, p_n_cloud_c);
    ```

6. 判断点云是否有组织：

    ```cpp
    cloud.isOrganized()
    ```

    - 有组织点云示例：

        ```cpp
        cloud.width = 640;      // Image-like organized structure, with 480 rows and 640 columns,
        cloud.height = 480;     // thus 640*480=307200 points total in the dataset
        ```

    - 无组织点云示例：

        ```cpp
        cloud.width = 307200;
        cloud.height = 1;       // unorganized point cloud dataset with 307200 points
        ```

## 滤波

### VoxelGrid

```cpp
#include <pcl/filters/voxel_grid.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);

// Create the filtering object
pcl::VoxelGrid<pcl::PCLPointCloud2> sor;
sor.setInputCloud(cloud);
sor.setLeafSize(0.01f, 0.01f, 0.01f);
sor.filter(*cloud_filtered);
```

### ApproximateVoxelGrid

```cpp
#include <pcl/filters/approximate_voxel_grid.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr input_cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr filtered_cloud(new pcl::PointCloud<pcl::PointXYZ>);

// Filtering input scan to roughly 10% of original size to increase speed of registration.
pcl::ApproximateVoxelGrid<pcl::PointXYZ> approximate_voxel_filter;
approximate_voxel_filter.setLeafSize(0.2, 0.2, 0.2);
approximate_voxel_filter.setInputCloud(input_cloud);
approximate_voxel_filter.filter(*filtered_cloud);
```

### StatisticalOutlierRemoval

```cpp
#include <pcl/filters/statistical_outlier_removal.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);

// Create the filtering object
pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
sor.setInputCloud(cloud);
sor.setMeanK(50);
sor.setStddevMulThresh(1.0);
sor.filter(*cloud_filtered);
```

### RadiusOutlierRemoval

```cpp
#include <pcl/filters/radius_outlier_removal.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);

pcl::RadiusOutlierRemoval<pcl::PointXYZ> outrem;
// build the filter
outrem.setInputCloud(cloud);
outrem.setRadiusSearch(0.8);
outrem.setMinNeighborsInRadius(2);
outrem.setKeepOrganized(true);
// apply filter
outrem.filter(*cloud_filtered);
```

### ConditionalRemoval

```cpp
#include <pcl/filters/conditional_removal.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);

pcl::ConditionAnd<pcl::PointXYZ>::Ptr range_cond(new pcl::ConditionAnd<pcl::PointXYZ>());
range_cond->addComparison(pcl::FieldComparison<pcl::PointXYZ>::ConstPtr(new pcl::FieldComparison<pcl::PointXYZ>("z", pcl::ComparisonOps::GT, 0.0)));
range_cond->addComparison(pcl::FieldComparison<pcl::PointXYZ>::ConstPtr(new pcl::FieldComparison<pcl::PointXYZ>("z", pcl::ComparisonOps::LT, 0.8)));
// build the filter
pcl::ConditionalRemoval<pcl::PointXYZ> condrem;
condrem.setCondition(range_cond);
condrem.setInputCloud(cloud);
condrem.setKeepOrganized(true);
// apply filter
condrem.filter(*cloud_filtered);
```

## 配准

### ICP

```cpp
#include <pcl/registration/icp.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_in(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_out(new pcl::PointCloud<pcl::PointXYZ>);

pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
icp.setInputSource(cloud_in);
icp.setInputTarget(cloud_out);

pcl::PointCloud<pcl::PointXYZ> Final;
icp.align(Final)
std::cout << "has converged:" << icp.hasConverged() << " score: " <<
icp.getFitnessScore() << std::endl;
std::cout << icp.getFinalTransformation() << std::endl;
```

### NDT

```cpp
#include <pcl/registration/ndt.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr target_cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::PointCloud<pcl::PointXYZ>::Ptr filtered_cloud(new pcl::PointCloud<pcl::PointXYZ>);

// Initializing Normal Distributions Transform (NDT).
pcl::NormalDistributionsTransform<pcl::PointXYZ, pcl::PointXYZ> ndt;

// Setting scale dependent NDT parameters
// Setting minimum transformation difference for termination condition.
ndt.setTransformationEpsilon(0.01);
// Setting maximum step size for More-Thuente line search.
ndt.setStepSize(0.1);
// Setting Resolution of NDT grid structure (VoxelGridCovariance).
ndt.setResolution(1.0);

// Setting max number of registration iterations.
ndt.setMaximumIterations(35);

// Setting point cloud to be aligned.
ndt.setInputSource(filtered_cloud);
// Setting point cloud to be aligned to.
ndt.setInputTarget(target_cloud);
```

## KdTree

```cpp
#include <pcl/kdtree/kdtree_flann.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::KdTreeFLANN<pcl::PointXYZ> kdtree;
pcl::PointXYZ searchPoint;

kdtree.setInputCloud(cloud);

// K nearest neighbor search
int K = 10;
std::vector<int> pointIdxKNNSearch(K);
std::vector<float> pointKNNSquaredDistance(K);

// 返回值为找到最近邻的个数
kdtree.nearestKSearch(searchPoint, K, pointIdxKNNSearch,
                      pointKNNSquaredDistance);
// 最近邻点
// (*cloud)[pointIdxKNNSearch[i]]

// Neighbors within radius search
std::vector<int> pointIdxRadiusSearch;
std::vector<float> pointRadiusSquaredDistance;
float radius;

// 返回值为找到最近邻的个数
kdtree.radiusSearch(searchPoint, radius, pointIdxRadiusSearch,
                    pointRadiusSquaredDistance);
// 最近邻点
// (*cloud)[pointIdxRadiusSearch[i]]
```

## 输入输出

### PCD文件格式

1. 文件头需要**严格按照**以下顺序：

    ```text
    VERSION
    FIELDS
    SIZE
    TYPE
    COUNT
    WIDTH
    HEIGHT
    VIEWPOINT
    POINTS
    DATA
    ```

    - `VERSION`：PCD文件版本，PCL要求0.7；
    - `FIELDS`：点的每个维度对应的数据含义：

        ```text
        FIELDS x y z                                # XYZ data
        FIELDS x y z rgb                            # XYZ + colors
        FIELDS x y z normal_x normal_y normal_z     # XYZ + surface normals
        FIELDS j1 j2 j3                             # moment invariants
        ```

    - `SIZE`：点的每个维度占据的字节数：

        | 数据类型 | 字节数 |
        | :--- | :--- |
        | unsigned char / char | 1 |
        | unsigned short / short | 2 |
        | unsigned int / int / float | 4 |
        | double | 8 |

    - `TYPE`：点的每个维度对应的数据类型：

        | 数据类型 | 字符表示 |
        | :--- | :--- |
        | 有符号：int8（char）、int16（short）、int32（int） | `I` |
        | 无符号：uint8（unsigned char）、uint16（unsigned short）、uint32（unsigned int） | `U` |
        | float | `F` |

    - `COUNT`：点的每个维度包含的元素个数，默认为1；
    - `WIDTH`：点云的列数，对于无组织点云为点的总数；
    - `HEIGHT`：点云的行数，对于无组织点云为1；
    - `VIEWPOINT`：点云的采集视角，使用向量表示平移，使用四元数表示旋转，默认旋转和平移为0：

        ```text
        tx ty tz qw qx qy qz
        ```

    - `POINTS`：点的总数；
    - `DATA`：存储方式：

        | 存储方式 | 说明 | 优势 |
        | :--- | :--- | :--- |
        | `ascii` | 使用ASCII码存储 | 简洁直观，便于第三方软件读取 |
        | `binary` | 使用二进制存储，内存拷贝 | 读取速度最快 |
        | `binary_compressed` | 使用二进制存储，LZF算法压缩 | 压缩后大小为`binary`的30%-60%，读取时需要解压缩 |

2. 数据每个点占一行，使用`nan`表示NaN：

    ```text
    p_1
    p_2
    p_3
    p_4
    ...

    p_n
    ```

3. 文件头示例：

    ```text
    # .PCD v.7 - Point Cloud Data file format
    VERSION .7
    FIELDS x y z rgb
    SIZE 4 4 4 4
    TYPE F F F F
    COUNT 1 1 1 1
    WIDTH 213
    HEIGHT 1
    VIEWPOINT 0 0 0 1 0 0 0
    POINTS 213
    DATA ascii
    0.93773 0.33763 0 4.2108e+06
    0.90805 0.35641 0 4.2108e+06
    0.81915 0.32 0 4.2108e+06
    0.97192 0.278 0 4.2108e+06
    0.944 0.29474 0 4.2108e+06
    ```

### 输入

```cpp
#include <pcl/io/pcd_io.h>

pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);
pcl::io::loadPCDFile<pcl::PointXYZ>("test_pcd.pcd", *cloud);
std::cout << "Loaded " << cloud->width * cloud->height
          << " data points from test_pcd.pcd with the following fields: "
          << std::endl;
```

### 输出

```cpp
#include <pcl/io/pcd_io.h>

pcl::PointCloud<pcl::PointXYZ> cloud;
pcl::io::savePCDFileASCII("test_pcd.pcd", cloud);
std::cerr << "Saved " << cloud.size () << " data points to test_pcd.pcd." << std::endl;
```

## 可视化

```cpp
pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud;
//... populate cloud
pcl::visualization::CloudViewer viewer("Simple Cloud Viewer");
viewer.showCloud(cloud);
while(!viewer.wasStopped()) {
}
```

1. 在可视化界面中使用`+`和`-`来增大和减小显示点的大小；
2. 在可视化界面中使用`1`-`5`设置点云颜色：

    - `1`：单色；
    - `2`：按照x坐标着色；
    - `3`：按照y坐标着色；
    - `4`：按照z坐标着色；
    - `5`：按照反射强度着色；

3. 在可视化界面中使用`r`重现视角；
4. 在可视化界面中使用`j`截图；
5. 在可视化界面中使用`g`显示或隐藏坐标轴；

## 参考

1. [pcl](https://pcl.readthedocs.io/en/latest/)
2. [pcl-docs](https://pcl-docs.readthedocs.io/en/latest/)
3. [点云与点云指针类型转换1-CSDN博客](https://blog.csdn.net/h287850870/article/details/80988552)
4. [点云与点云指针类型转换2-CSDN博客](https://blog.csdn.net/tfb760/article/details/115101393)
5. [关于PCL库中makeshared转换智能指针的问题-小透明的文章-知乎](https://zhuanlan.zhihu.com/p/442236714)
6. [pcl_viewer-CSDN博客](https://blog.csdn.net/qq_39779233/article/details/106985091)
